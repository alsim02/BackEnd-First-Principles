# Appunti: Mastering Databases con Postgres

## 1. Perché abbiamo bisogno di database
- Un database permette di **persistere i dati** tra diverse sessioni, mantenendo lo stato anche dopo la chiusura del programma.
- Esempio: in un'app to-do, i compiti segnati come completati devono rimanere quando si riapre l’app.

## 2. Definizione di database
- Un sistema di archiviazione strutturata che permette di creare, leggere, aggiornare e cancellare dati (CRUD).
- Può essere un semplice elenco contatti, un file di testo o strutture avanzate come DBMS.
- Nei sistemi backend, ci si riferisce principalmente a database **basati su disco** (HDD o SSD).

## 3. Database vs Memoria RAM
- RAM è veloce ma costosa e limitata in capacità.
- Dischi (storage secondario) sono più lenti ma più economici e capienti.
- Per migliorare le performance si usa caching in RAM (es. Redis), mentre i database tradizionali memorizzano dati su disco.

## 4. Database Management System (DBMS)
- Software che organizza, gestisce e ottimizza le operazioni CRUD su dati strutturati.
- Gestione di integrità, sicurezza, scalabilità.
- Offre metodi efficienti di accesso e modifica dati.

## 5. Perché non usare semplici file di testo
- Parsing lento e soggetto a errori.
- Mancanza di struttura e integrità.
- Problemi di concorrenza nell'accesso simultaneo.
- Necessità di sistemi dedicati come i DBMS.

## 6. Tipologie di DBMS
- **Relazionali:** dati organizzati in tabelle con righe, colonne e schema rigido (es. Postgres, MySQL, SQL Server).
- **Non-Relazionali (NoSQL):** dati più flessibili, schema dinamico, possono memorizzare documenti JSON (es. MongoDB).

## 7. Scelta tra Relazionale e Non-Relazionale
- Relazionale per dati strutturati e integrità forte (es. CRM).
- Non-Relazionale per dati non strutturati o variabili (es. CMS, contenuti dinamici).
- Le non-relazionali richiedono più responsabilità a livello applicativo per integrità.

## 8. Perché scegliere Postgres
- Open source, ampiamente supportato.
- Adesione allo standard SQL.
- Ottima estendibilità e ricchezza di funzionalità.
- Eccellente supporto per dati JSON e indicizzazione avanzata.
- Affidabile e scalabile.
- Facilmente migrabile verso altri DB relazionali.

## 9. Nozioni di base su SQL e Postgres
- Linguaggio SQL usato per interrogare e modificare dati.
- Esempi base sono disponibili abbondantemente come risorse di apprendimento.

## 10. Tipi di dati importanti in Postgres
- **Serial, BigSerial:** interi auto-incrementali per chiavi primarie.
- **Integer, SmallInt, BigInt:** variazioni per capacità numerica.
- **Decimal, Numeric:** numeri con precisione esatta (importante per prezzi).
- **Real, Double Precision (Floating Point):** numeri approssimativi e più veloci.
- **Stringhe:** `CHAR` (fisso), `VARCHAR` (lunghezza variabile), `TEXT` (senza limite, consigliato).
- **Boolean:** true o false.
- **Date, Time, Timestamp:** dati temporali con o senza timezone.
- **UUID:** identificatori univoci globali per chiavi primarie.
- **JSON, JSONB:** dati in formato JSON, con "JSONB" ottimizzato per prestazioni.
- **Array:** array di qualsiasi tipo di dato.
- Tipi speciali: indirizzi di rete, geometria, XML, ecc.

## 11. Inserimento dati
- Comando SQL `INSERT INTO` segue ordine campi e valori.
- Esempi con vari tipi di dati mostrano sintassi standard.

## 12. Scenari pratici di uso database
- Progetto di esempio: piattaforma di gestione progetti con tabelle per organizzazioni, progetti e task.
- DB schema progettato in base ai requisiti emersi.
- Collegamento tra design API e schema DB.

## 13. Normalizzazione e progettazione del database
- **Normalizzazione:** processo che organizza i dati per ridurre ridondanze e anomalie.
- Obiettivo: creare schemi che garantiscano integrità, efficienza e facilità di manutenzione.
- Le normalizzazioni si effettuano rispettando una serie di "forme normali":
  - **Prima Forma Normale (1NF):** ogni campo deve contenere valori atomici (indivisibili), senza gruppi ripetitivi.
  - **Seconda Forma Normale (2NF):** si applica a tabelle con chiave primaria composta; ogni attributo non chiave deve dipendere da tutta la chiave, non da una parte.
  - **Terza Forma Normale (3NF):** elimina le dipendenze transitive tra attributi non chiave (un attributo non chiave non deve dipendere indirettamente da una chiave).
  - Oltre la 3NF ci sono forme più avanzate come BCNF, 4NF, 5NF ma spesso la 3NF è sufficiente per la maggior parte dei DB.
- **Progettazione del database:**
  - Partire dall’analisi delle entità (risorse) e delle loro relazioni.
  - Identificare le chiavi primarie per ogni tabella.
  - Applicare le forme normali per strutturare le tabelle.
  - Bilanciare tra normalizzazione (evitare ridondanze) e prestazioni (a volte denormalizzare per efficienza).
  - Definire gli indici per ottimizzare le query più frequenti.
- Una buona progettazione migliora la coerenza, la scalabilità e la manutenibilità del sistema.

---

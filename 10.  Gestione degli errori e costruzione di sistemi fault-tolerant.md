# Appunti: Gestione degli errori e costruzione di sistemi fault-tolerant

## 1. Introduzione
- Gli errori sono inevitabili nello sviluppo backend.
- La vera domanda è come prepararci e gestirli per mantenere sistemi robusti e affidabili.

## 2. Tipi di errori comuni nel backend
- **Errori di logica:** codice esegue ma con risultati errati (es. applicare sconto doppio che causa perdite).
- **Errori di database:** connessione, deadlock, violazioni di vincoli (unique, foreign key), query mal formate.
- **Errori di servizi esterni:** timeout, errori di rete, limitazioni come rate limiting (es. API esterne, servizi email).
- **Errori di validazione input:** dati errati o malformati inviati dagli utenti.
- **Errori di configurazione:** variabili mancanti o errate tra ambienti dev/staging/produzione.

## 3. Errori di logica
- Difficili da rilevare perché non causano crash, ma producono risultati sbagliati.
- Cause frequenti: incomprensione requisiti, implementazione errata, mancata gestione edge cases.

## 4. Errori di database
- Connessione assente o esaurita causa errori 500 e app bloccata.
- Violazioni di vincolo: es. email duplicata, riferimenti a entità inesistenti (foreign key).
- Query malformate o deadlock che bloccano l’esecuzione.

## 5. Errori di servizi esterni
- Mancanza di controllo su uptime o performance di servizi esterni.
- Necessità di gestire timeout, errori di autenticazione e rate limiting (code 429).
- Strategia: esponenziali backoff per retry; fallback e degradazione controllata.

## 6. Validazione utenti e input
- Prima linea di difesa per evitare dati errati.
- Regole di formato, range, campi obbligatori.
- Errori gestiti con risposte HTTP 400 con messaggi chiari all’utente.

## 7. Errori di configurazione
- Mancata presenza di variabili ambientali richieste può far fallire l’avvio dell’app.
- Meglio fallire all’avvio che crashare in produzione.
- Validare sempre configurazioni prima del deploy.

## 8. Strategie di prevenzione errori
- **Rilevamento precoce:** health checks per server, database, servizi esterni.
- Testare la funzionalità reale (es. query di salute, transazioni di test).
- Validazione di configurazioni e dati in ingresso.

## 9. Monitoraggio e osservabilità
- Fondamentale per individuare errori subito e diagnosticare rapidamente.
- Monitorare tipi di errori (HTTP, DB, esterni, di business).
- Tracciare metriche di performance e business (es. tassi di successo transazioni).
- Uso di logging strutturato, aggregazione (Graphana, Loki, ELK).

## 10. Gestione immediata degli errori
- Risposta rapida e appropriata all’errore (es. retry per errori temporanei, degradazione per irreversibili).
- Evitare di sovraccaricare sistemi già in difficoltà.

## 11. Strategie di ripristino
- Ripristino automatico (es. riavvio servizi, pulizia cache).
- Ripristino manuale per errori critici con procedure documentate e testate.
- Priorità massima alla salvaguardia e integrità dei dati (backup, restore, log di transazioni).

## 12. Propagazione controllata degli errori
- Uso di stack trace e gestione gerarchica delle eccezioni.
- Bolle le eccezioni ai livelli adeguati per aggiungere contesto e logging.
- Evitare che errori si propaghino incontrollati causando crash a cascata.

## 13. Global error handling (gestione globale degli errori)
- Middleware centrale per intercettare tutte le eccezioni non gestite.
- Traduce errori in risposte HTTP coerenti, con codici e messaggi user-friendly.
- Isola errori evitando che blocchino l’intera applicazione.

## 14. Esempi pratici
- Validazione fallita in handler → errore 400 con messaggio di dettaglio.
- Violazione vincolo unico a DB → errore 400 con messaggio esplicito.
- Risorsa non trovata → 404 col messaggio corretto.
- Errori di logica o interni → 500 oppure messaggi più specifici in base alla criticità.

---
